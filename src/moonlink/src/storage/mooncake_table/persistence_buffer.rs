use std::collections::HashSet;

use crate::storage::index::persisted_bucket_hash_map::GlobalIndex;
use crate::storage::mooncake_table::SnapshotTask;
use crate::storage::storage_utils::MooncakeDataFileRef;
use crate::TableConfig as MooncakeTableConfig;

use more_asserts as ma;

/// Struct which stores unpersisted content for mooncake table.
#[derive(Clone, Debug, Default)]
pub(crate) struct UnpersistedRecords {
    /// Mooncake table config.
    mooncake_table_config: MooncakeTableConfig,

    /// ===========================================
    /// Records generated by new writes
    /// ===========================================
    ///
    /// Unpersisted data files, new data files are appended to the end.
    unpersisted_data_files: Vec<MooncakeDataFileRef>,
    /// Unpersisted file indices, new indices are appended to the end.
    unpersisted_file_indices: Vec<GlobalIndex>,
    /// ===========================================
    /// Records generated by index merge
    /// ===========================================
    ///
    /// Unpersisted old merged file indices, which should not appear in the later iceberg snapshots.
    merged_file_indices_to_remove: Vec<GlobalIndex>,
    /// Unpersisted new merged indices, which should be added to the later iceberg snapshots.
    ///
    /// TODO(hjiang): Consider using hash set for faster lookup.
    merged_file_indices_to_add: Vec<GlobalIndex>,
    /// ===========================================
    /// Records generated by data compaction
    /// ===========================================
    ///
    /// Unpersisted old compacted data files, which should not appear in the later iceberg snapshots.
    compacted_data_files_to_remove: Vec<MooncakeDataFileRef>,
    /// Unpersisted new compacted data files, which should be added in the later iceberg snapshots.
    compacted_data_files_to_add: Vec<MooncakeDataFileRef>,
    /// Unpersisted old compacted file indices, which should not appear in the later iceberg snapshots.
    compacted_file_indices_to_remove: Vec<GlobalIndex>,
    /// Unpersisted new compacted file indices, which should be added in the later iceberg snapshots.
    compacted_file_indices_to_add: Vec<GlobalIndex>,
}

impl UnpersistedRecords {
    pub(crate) fn new(mooncake_table_config: MooncakeTableConfig) -> Self {
        Self {
            mooncake_table_config,
            ..Default::default()
        }
    }

    /// ==================================
    /// Getters
    /// ==================================
    ///
    pub(crate) fn get_unpersisted_data_files(&self) -> Vec<MooncakeDataFileRef> {
        self.unpersisted_data_files.clone()
    }
    pub(crate) fn get_unpersisted_file_indices(&self) -> Vec<GlobalIndex> {
        self.unpersisted_file_indices.clone()
    }
    /// Index merge.
    pub(crate) fn get_merged_file_indices_to_add(&self) -> Vec<GlobalIndex> {
        self.merged_file_indices_to_add.clone()
    }
    pub(crate) fn get_merged_file_indices_to_remove(&self) -> Vec<GlobalIndex> {
        self.merged_file_indices_to_remove.clone()
    }
    /// Data compaction.
    pub(crate) fn get_compacted_data_files_to_add(&self) -> Vec<MooncakeDataFileRef> {
        self.compacted_data_files_to_add.clone()
    }
    pub(crate) fn get_compacted_data_files_to_remove(&self) -> Vec<MooncakeDataFileRef> {
        self.compacted_data_files_to_remove.clone()
    }
    pub(crate) fn get_compacted_file_indices_to_add(&self) -> Vec<GlobalIndex> {
        self.compacted_file_indices_to_add.clone()
    }
    pub(crate) fn get_compacted_file_indices_to_remove(&self) -> Vec<GlobalIndex> {
        self.compacted_file_indices_to_remove.clone()
    }

    /// Get unpersisted data files as hash set for lookup.
    pub(crate) fn get_unpersisted_data_files_set(&self) -> HashSet<MooncakeDataFileRef> {
        self.unpersisted_data_files
            .iter()
            .cloned()
            .collect::<HashSet<_>>()
    }
    /// Get unpersisted file indices as hash set for lookup.
    #[allow(clippy::mutable_key_type)]
    pub(crate) fn get_unpersisted_file_indices_set(&self) -> HashSet<GlobalIndex> {
        self.unpersisted_file_indices
            .iter()
            .cloned()
            .collect::<HashSet<_>>()
    }

    /// ==================================
    /// Buffer utils
    /// ==================================
    ///
    fn buffer_unpersisted_iceberg_new_data_files(&mut self, task: &SnapshotTask) {
        let new_data_files = task.get_new_data_files();
        self.unpersisted_data_files.extend(new_data_files);
    }
    fn buffer_unpersisted_iceberg_new_file_indices(&mut self, task: &SnapshotTask) {
        let new_file_indices = task.get_new_file_indices();
        self.unpersisted_file_indices.extend(new_file_indices);
    }
    fn buffer_unpersisted_iceberg_merged_file_indices(&mut self, task: &SnapshotTask) {
        let index_merge_result = &task.index_merge_result;
        self.merged_file_indices_to_add
            .extend(index_merge_result.new_file_indices.to_owned());
        self.merged_file_indices_to_remove
            .extend(index_merge_result.old_file_indices.to_owned());
    }

    fn buffer_unpersisted_iceberg_compaction_data(&mut self, task: &SnapshotTask) {
        let data_compaction_res = &task.data_compaction_result;
        if data_compaction_res.is_empty() {
            return;
        }

        let data_compaction_res = data_compaction_res.clone();
        let l = data_compaction_res.new_data_files.len();

        let mut new_compacted_data_files = Vec::with_capacity(l);
        for (new_data_file, _) in data_compaction_res.new_data_files.into_iter() {
            new_compacted_data_files.push(new_data_file.clone());
        }

        self.compacted_data_files_to_add
            .extend(new_compacted_data_files);
        self.compacted_data_files_to_remove
            .extend(data_compaction_res.old_data_files);
        self.compacted_file_indices_to_add
            .extend(data_compaction_res.new_file_indices);
        self.compacted_file_indices_to_remove
            .extend(data_compaction_res.old_file_indices);
    }

    /// Buffer unpersisted records.
    pub(crate) fn buffer_unpersisted_records(&mut self, task: &SnapshotTask) {
        self.buffer_unpersisted_iceberg_new_data_files(task);
        self.buffer_unpersisted_iceberg_new_file_indices(task);
        self.buffer_unpersisted_iceberg_merged_file_indices(task);
        self.buffer_unpersisted_iceberg_compaction_data(task);
    }

    /// ==================================
    /// Prune utils
    /// ==================================
    ///
    /// Update unpersisted data files from successful iceberg snapshot operation.
    fn prune_persisted_data_files(&mut self, task: &SnapshotTask) {
        let persisted_new_data_files = &task.iceberg_persisted_records.data_files;
        ma::assert_ge!(
            self.unpersisted_data_files.len(),
            persisted_new_data_files.len()
        );
        self.unpersisted_data_files
            .drain(0..persisted_new_data_files.len());
    }

    /// Update unpersisted file indices from successful iceberg snapshot operation.
    fn prune_persisted_file_indices(&mut self, task: &SnapshotTask) {
        let persisted_new_file_indices = &task.iceberg_persisted_records.file_indices;
        ma::assert_ge!(
            self.unpersisted_file_indices.len(),
            persisted_new_file_indices.len()
        );
        self.unpersisted_file_indices
            .drain(0..persisted_new_file_indices.len());
    }

    fn prune_persisted_merged_indices(&mut self, task: &SnapshotTask) {
        let old_merged_file_indices = &task.iceberg_persisted_records.old_merged_file_indices;
        ma::assert_ge!(
            self.merged_file_indices_to_remove.len(),
            old_merged_file_indices.len()
        );
        self.merged_file_indices_to_remove
            .drain(0..old_merged_file_indices.len());

        let new_merged_file_indices = &task.iceberg_persisted_records.new_merged_file_indices;
        ma::assert_ge!(
            self.merged_file_indices_to_add.len(),
            new_merged_file_indices.len()
        );
        self.merged_file_indices_to_add
            .drain(0..new_merged_file_indices.len());
    }

    fn prune_persisted_compacted_data(&mut self, task: &SnapshotTask) {
        let persisted_compaction_res = &task.iceberg_persisted_records;
        ma::assert_ge!(
            self.compacted_data_files_to_add.len(),
            persisted_compaction_res.new_compacted_data_files.len()
        );
        self.compacted_data_files_to_add
            .drain(0..persisted_compaction_res.new_compacted_data_files.len());

        ma::assert_ge!(
            self.compacted_data_files_to_remove.len(),
            persisted_compaction_res.old_compacted_data_files.len()
        );
        self.compacted_data_files_to_remove
            .drain(0..persisted_compaction_res.old_compacted_data_files.len());

        ma::assert_ge!(
            self.compacted_file_indices_to_add.len(),
            persisted_compaction_res.new_compacted_file_indices.len()
        );
        self.compacted_file_indices_to_add
            .drain(0..persisted_compaction_res.new_compacted_file_indices.len());

        ma::assert_ge!(
            self.compacted_file_indices_to_remove.len(),
            persisted_compaction_res.old_compacted_file_indices.len()
        );
        self.compacted_file_indices_to_remove
            .drain(0..persisted_compaction_res.old_compacted_file_indices.len());
    }

    /// Prune persisted records.
    pub(crate) fn prune_persisted_records(&mut self, task: &SnapshotTask) {
        self.prune_persisted_data_files(task);
        self.prune_persisted_file_indices(task);
        self.prune_persisted_merged_indices(task);
        self.prune_persisted_compacted_data(task);
    }

    /// ==================================
    /// Persistence utils
    /// ==================================
    ///
    /// Util function to decide whether to create iceberg snapshot by data compaction results.
    pub(crate) fn if_persist_by_data_compaction(&self, force_create: bool) -> bool {
        force_create
            && (!self.compacted_data_files_to_add.is_empty()
                || !self.compacted_data_files_to_remove.is_empty())
    }

    /// TODO(hjiang): Decide when to create iceberg snapshot by index merge and data compaction.
    /// Util function to decide whether to create iceberg snapshot by index merge results.
    pub(crate) fn if_persist_by_index_merge(&self, force_create: bool) -> bool {
        force_create && !self.merged_file_indices_to_add.is_empty()
    }

    /// Util function to decide whether to create iceberg snapshot by new data files.
    pub(crate) fn if_persist_by_data_files(&self, force_create: bool) -> bool {
        let data_file_snapshot_threshold = if !force_create {
            self.mooncake_table_config
                .iceberg_snapshot_new_data_file_count()
        } else {
            1
        };
        self.unpersisted_data_files.len() >= data_file_snapshot_threshold
    }
}
